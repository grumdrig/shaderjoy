<!doctype html>
<head>
<title>Shaderjoy</title>
</head>
<body>
<div id=title>Shaderjoy</div>
<canvas draggable=true></canvas>
<div id=status>
	<span id="rewind"></span>
	<span id="pause">&#10073;&#10073;</span>
	<span id="clock"></span>
	<span id="fps"></span> fps
	<span id="timer">?</span> msec
	Mouse:
	<select id="mouseaction">
		<option value="interact">Interact</option>
		<option value="resize">Resize</option>
		<option value="getcolor">Get color</option>
	</select>
</div>
<div id=list></div>
<pre id=err></pre>
<form>
<style>
	input { font-size: 14px; }
	#err { color: #800; }
	.item {
		color: blue;
		cursor: default;
		background-color: #ffe;
		margin: 4px;
		padding: 4px;
	}
	.item:before {
		content: "\2602\0020";
	}
	.selected { font-weight: bold }
	div { font-family: Tahoma; font-size: 14px; }
	#status, #title {
		font-weight: bold;
		margin-bottom: 10px;
	}
	#list { margin-bottom: 10px; }
	#title { font-family: Bookman; font-size: 20px; font-style: italic; }
	body { background-color: #d2d0d2; margin-left: 100px; }
	#rewind, #pause { cursor: default; width: 10px; display: inline-block; }
	#rewind:before { content: "\21e4" }
	#status span { margin-left: 10px; }
</style>
<script>

function $(s) { return document.querySelector(s); }

function mouseaction() { return $("#mouseaction").value }

let canvas = $("canvas");
canvas.width = 500;
canvas.height = 281;
canvas.iMouse = [0,0,0,0];
let gl = canvas.getContext("webgl2", { preserveDrawingBuffer: true });
let program;
let SHADERS = {};

let ext = gl.getExtension('EXT_disjoint_timer_query_webgl2');

canvas.addEventListener("drag", function (e) {
	if (mouseaction() == "resize") {
		if (e.clientX > 0 && e.clientY > 0) {
			canvas.width = e.x - canvas.offsetLeft;
			canvas.height = e.y - canvas.offsetTop;
		}
	} else if (mouseaction() === "interact") {
		if (e.clientX > 0 && e.clientY > 0) {
			[canvas.iMouse[0], canvas.iMouse[1]] = mousePos(e);
		}
	}

});

// This isn't quite the way shadertoy decides mouse positions, regarding
// clicks, but since dragging resizes, just going with this scheme, for the
// time being at least.

function mousePos(e) {
	let rect = canvas.getBoundingClientRect();
	return [e.clientX - rect.left,
			rect.height - 1 - (e.clientY - rect.top)];
}

canvas.addEventListener("mousemove", function (e) {
	let [mx, my] = mousePos(e);
	if (mouseaction() === "getcolor") {
		let p = new Uint8Array(4);
		gl.readPixels(mx, my, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, p);
	    $("body").style.backgroundColor = `rgb(${p[0]},${p[1]},${p[2]})`;
	    $("body").style.color = contrastingColor(p[0], p[1], p[2]);
	}
});

canvas.addEventListener("mousedown", function (e) {
	if (mouseaction() == "interact") {
		[canvas.iMouse[0], canvas.iMouse[1]] = [canvas.iMouse[2], canvas.iMouse[3]] = mousePos(e);
	}
});

canvas.addEventListener("dragend", function (e) {
	console.log("dragend");
	if (mouseaction() == "interact") {
		[canvas.iMouse[2], canvas.iMouse[3]] = [-canvas.iMouse[2], -canvas.iMouse[3]];
	}
});

function contrastingColor(r, g, b) {
	const abs = Math.abs, min = Math.min;
	const dr = abs(r - 128);
	const dg = abs(g - 128);
	const db = abs(b - 128);
	if (dr < min(dg, db)) {
		return `rgb(${r < 128 ? 255 : 0},${255-g},${255-b})`;
	} else if (dg < db) {
		return `rgb(${255-r},${g < 128 ? 255 : 0},${255-b})`;
	} else {
		return `rgb(${255-r},${255-g},${b < 128 ? 255 : 0})`;
	}
}

function go(link) {
	let vertexShader = gl.createShader(gl.VERTEX_SHADER);
	gl.shaderSource(vertexShader, `#version 300 es
		precision highp float;

		in vec2 aPosition;

		void main() {
			gl_Position = vec4(aPosition, 0, 1);
		}
	`);
	gl.compileShader(vertexShader);
	if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(vertexShader));

	let fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	gl.shaderSource(fragmentShader, `#version 300 es
		precision highp float;

		uniform vec3      iResolution;           // viewport resolution (in pixels)
		uniform float     iGlobalTime;           // shader playback time (in seconds)
		uniform float     iTimeDelta;            // render time (in seconds)
		uniform int       iFrame;                // shader playback frame
		uniform vec4      iMouse;                // mouse pixel coords. xy: current (if MLB down), zw: click
		uniform vec4      iDate;                 // (year, month, day, time in seconds)

		#line 1
		${link.currentContents}

		out vec4 FragColor;

		void main() {
			mainImage(FragColor, gl_FragCoord.xy);
		}
	`);
	gl.compileShader(fragmentShader);
	if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(fragmentShader), link.filename);

	program = gl.createProgram()
	gl.attachShader(program, vertexShader);
	gl.attachShader(program, fragmentShader);
	gl.linkProgram(program);
	if (!gl.getProgramParameter(program, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(program));
	gl.useProgram(program);

	gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, +1,-1, -1,+1,
		                                             -1,+1, +1,-1, +1,+1]), gl.STATIC_DRAW, 0);
	gl.vertexAttribPointer(0, 2, gl.FLOAT, gl.FALSE, 0, 0);
	gl.enableVertexAttribArray(0);

	window.requestAnimationFrame(tick);
}

function reload(firstTime) {
	var ls = new XMLHttpRequest();
	ls.open("GET", "./?now=" + +new Date(), true);
	for (let i in SHADERS) SHADERS[i].request = null;
	ls.onload = function (e) {
		if (this.status != 200) throw new Error("Error loading directory listing");
		let newest;
		let re = /href="(.+)\.glsl"/g, match;
		while (match = re.exec(this.responseText)) {
			let filename = match[1];

			let link = SHADERS[filename];
			if (!link) {
				link = SHADERS[filename] = document.createElement('span');
				link.filename = filename;
				link.innerHTML = filename;
				link.classList.add("item");
				link.onclick = function (e) { this.currentContents = 0; }  // Cause a reload
				$("#list").appendChild(link);
			}
			link.request = new XMLHttpRequest();
			link.request.open("GET", filename + ".glsl?now=" + +new Date(), true);
			//link.request.responseType = "blob";
			link.request.onload = function (e) {
				if (this.status != 200) throw new Error("Error loading script");
				if (link.currentContents !== this.responseText) {
					link.lastModified = +new Date(this.getResponseHeader("Last-Modified"));
					console.log("Loading", filename, link.lastModified);
					link.currentContents = this.responseText;

					if (firstTime) {
						// This first time, just load the most recently modified file
						for (let i in SHADERS) {
							if (!SHADERS[i].currentContents)
								return;  // Still loading
							if (SHADERS[i].lastModified > link.lastModified) {
								link = SHADERS[i];
							}
						}
						$("#title").innerText = link.filename;
					}

					try {
						$("#err").innerText = "";
						for (let i in SHADERS) {
							if (SHADERS[i] === link) {
								SHADERS[i].classList.add("selected");
							} else {
								SHADERS[i].classList.remove("selected");
							}
						}
						go(link);
						$("#title").innerText = link.filename;
					} catch (e) {
						let numbered = link.currentContents.split('\n').map((c,i)=>i+1 + ": " + c).join('\n');
						$("#err").innerText = `Error compiling "${link.filename}":\n${e}\n${numbered}`;
					}

				}
			}
			link.request.send();
		}
		for (let i in SHADERS) {
			if (!SHADERS[i].request) {
				SHADERS[i].parentElement.removeChild(SHADERS[i]);
				delete SHADERS[i];
			}
		}
 		setTimeout(reload, 200);
	}
	ls.send();
}

let PAUSED = false;
let T0, T1 = 0, DT = 0;
let FRAME = 0;
$("#rewind").onclick = rewind;
function rewind() {
	T0 = null;
	if (PAUSED) PAUSED = 0;
}
rewind();

$("#pause").onclick = function (e) {
	if (PAUSED !== false) {
		T0 = performance.now() - PAUSED;
		PAUSED = false;
	} else {
		PAUSED = T1 - T0;
	}
	this.innerHTML = PAUSED ? "&#9658;" : "&#10073;&#10073;";
}


let timer = 0;

function tick() {
	if (PAUSED == false) {
		let clock = performance.now();
		gl.viewport(0, 0, canvas.width, canvas.height);
		if (T0 === null) {
			T0 = clock;
			FRAME = 0;
		}
		FRAME++;
		const now = (clock - T0)/1000;
		const dk = .99;
		DT = DT * dk + (1-dk) * (clock - T1)/1000;
		$("#clock").innerText = now.toFixed(2);
		$("#fps").innerText = (1 / DT).toFixed(2);
		gl.uniform3f(gl.getUniformLocation(program, "iResolution"), canvas.width, canvas.height, 1);
		gl.uniform1f(gl.getUniformLocation(program, "iGlobalTime"), now);
		gl.uniform1f(gl.getUniformLocation(program, "iTimeDelta"), DT);
		gl.uniform1i(gl.getUniformLocation(program, "iFrame"), FRAME);
		gl.uniform4fv(gl.getUniformLocation(program, "iMouse"), canvas.iMouse);
		let today = new Date();
		gl.uniform4f(gl.getUniformLocation(program, "iDate"), today.getFullYear(), today.getMonth(), today.getDay(), +today);
		T1 = clock;

		if (ext && ext.query && (!ext.last || now - ext.last > 0.1)) {
			ext.last = now;
			const available = gl.getQueryParameter(ext.query, gl.QUERY_RESULT_AVAILABLE);
			const disjoint = gl.getParameter(ext.GPU_DISJOINT_EXT);

			if (available && !disjoint) {
				let timeElapsed = gl.getQueryParameter(ext.query, gl.QUERY_RESULT) / 1e6;
				$("#timer").innerText = timeElapsed.toFixed(4);
				gl.deleteQuery(ext.query);
				ext.query = null;
			}
		}

		let query;
		if (ext && !ext.query) {
			query = gl.createQuery();
			gl.beginQuery(ext.TIME_ELAPSED_EXT, query);
		}

		gl.drawArrays(gl.TRIANGLES, 0, 6);

		if (query) {
			ext.query = query;
			gl.endQuery(ext.TIME_ELAPSED_EXT);
		}
	}
	window.requestAnimationFrame(tick);
}

reload(true);

</script>
</body>